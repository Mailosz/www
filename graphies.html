<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="css/popupmenu.css">

    <style>
        body {
            display: flex;
            justify-content: stretch;
            flex-direction: column;
            margin: 0;
            height: 100vh;
            max-height: 100vh;
        }

        #toolbox {
            background: #eee;
        }

        #canvas-box {
            flex: 1;
        }
    </style>
</head>
<body>
    <div id="toolbox">
        <button id="generate-points">Generuj punkty</button>
        <button id="delete-points">Usuń wszystko</button>
        <button id="delete-edges">Usuń połączenia</button>
        &emsp;
        <button id="connect-points">Połącz</button>
        &emsp;
        <button id="circle-points">W kółko</button>
    </div>
    <div id="canvas-box" style=" position: relative; height: calc(100% - 20px)">
        <canvas id="view-canvas" style="width: 100%; height: 100%;">

        </canvas>
    </div>



    <script type="module">
        import {CanvasManager} from "./js/canvas/main.js";
        import {GraphiesDrawingManager, Node, Edge} from "./js/graphies/GraphiesDrawingManager.js";
        import {GraphiesInputManager} from "./js/graphies/GraphiesInputManager.js";

        /** @type {CanvasManager} */
        let cm;

        function initialize() {
            let canvas = document.getElementById('view-canvas');
            cm = new CanvasManager(canvas, new GraphiesDrawingManager(canvas.width, canvas.height));
            cm.setInputManager(new GraphiesInputManager());
        }

        initialize();

        document.getElementById("generate-points").addEventListener("click", (event) => {

            for (let i = 0; i < 100; i++) {

                let x = Math.random() * (cm.drawing.width - 20) + 10;
                let y = Math.random() * (cm.drawing.height - 20) + 10;

                cm.drawing.nodes.push(new Node(x, y));
                cm.drawing.redraw();

            }
        });

        document.getElementById("delete-points").addEventListener("click", (event) => {
            cm.drawing.nodes = [];
            cm.drawing.edges = [];

            cm.drawing.redraw();
        });

        document.getElementById("delete-edges").addEventListener("click", (event) => {removeAllEdges(); cm.drawing.redraw();});

        function removeAllEdges() {
            for (let node of cm.drawing.nodes) {

                node.edges = [];

            }

            cm.drawing.edges = [];
        }

        document.getElementById("connect-points").addEventListener("click", (event) => {
            console.time("connect-points");
            connectAllNodes();
            console.timeEnd("connect-points");

            cm.drawing.redraw();

        });

        document.getElementById("circle-points").addEventListener("click", (event) => {
            

            let i = 0;
            for (let node of cm.drawing.nodes) {
                let direction = (Math.PI * 2 / cm.drawing.nodes.length) * i;
                i++;

                let size = Math.min(cm.drawing.width, cm.drawing.height) / 2 - 10;

                let x = cm.drawing.width / 2 + Math.sin(direction) * size;
                let y = cm.drawing.height / 2 + Math.cos(direction) * size

                node.x = x;
                node.y = y;
            };

            cm.drawing.redraw();

        });

        function connectAllNodes() {
            if (cm.drawing.nodes.length < 2) return;
            removeAllEdges();

            let node = cm.drawing.nodes[0];
            let queue = [];
            let nearest = findNearestNode(node, cm.drawing.nodes);

            let nedge = new Edge(node, nearest);
            cm.drawing.edges.push(nedge);

            queue.push({a: node, b: nearest, edge: nedge});
            queue.push({a: nearest, b: node, edge: nedge});

            while (queue.length > 0) {
                let edge = queue.shift();
            
                let found = findNearestNodeOfEdge(edge);

                if (found.node != null) {

                    let leftEdge = edge.a.edges.find((e) => e.n1 == found.node || e.n2 == found.node);
                    if (leftEdge) {

                        if (leftEdge.final) { // this edge is final, do not add any new
                            continue;
                        }

                        // 
                        let index = queue.findIndex((e) => (e.a == edge.a || e.b == edge.a) && (e.a == found.node || e.b == found.node));

                        if (index >= 0) {
                            let contestedEdge = queue.splice(index, 1)[0];

                            let contestedFound = findNearestNodeOfEdge(contestedEdge);

                            if (contestedFound.node == edge.b) {
                                let nedge = new Edge(found.node, edge.b);
                                cm.drawing.edges.push(nedge);
                                queue.push({a: found.node, b: edge.b, edge: nedge});

                                edge.edge.final = true;
                                contestedEdge.edge.final = true;
                            } else if (contestedFound.distance < found.distance) {
                                queue.unshift(contestedEdge);
                            } else {
                                leftEdge.final = true;
                            }
                        } 
                        
                    } else {
                        let rightEdge = edge.b.edges.find((e) => e.n1 == found.node || e.n2 == found.node);
                        if (rightEdge) {
                            if (rightEdge.final) { // this edge is final, do not add any new
                                continue;
                            }
                            // 
                            let index = queue.findIndex((e) => (e.a == edge.b || e.b == edge.b) && (e.a == found.node || e.b == found.node));
                            if (index >= 0) {
                                let contestedEdge = queue.splice(index, 1)[0];

                                let contestedFound = findNearestNodeOfEdge(contestedEdge);

                                if (contestedFound.node == edge.a) {
                                    let nedge = new Edge(edge.a, found.node);
                                    cm.drawing.edges.push(nedge);
                                    queue.push({a: edge.a, b: found.node, edge: nedge});

                                    edge.edge.final = true;
                                    contestedEdge.edge.final = true;
                                } else if (contestedFound.distance < found.distance) {
                                    queue.unshift(contestedEdge);
                                } else {
                                    rightEdge.final = true;
                                }
                            }
                        } else {
                            //right = true;
                            let nedge1 = new Edge(edge.a, found.node);
                            cm.drawing.edges.push(nedge1);
                            queue.push({a: edge.a, b: found.node, edge: nedge1});

                            let nedge2 = new Edge(found.node, edge.b);
                            cm.drawing.edges.push(nedge2);
                            queue.push({a: found.node, b: edge.b, edge: nedge2});

                            edge.edge.final = true;
                        }
                    }
                }
            }
        }


        function contestNearest(found, contestedEdge) {

            

            if (contestedFound.node == found.node) {
                return true;
            } else if (contestedFound.distance < found.distance) {
                found.node = contestedFound.node;
                found.distance = contestedFound.distance;
                return true;
            } else {
                return false;
            }

        }

        function findNearestNodeOfEdge(edge) {
            let found = null;
            let dis = Number.POSITIVE_INFINITY;

            let point = {x: (edge.a.x + edge.b.x) / 2, y: (edge.a.y + edge.b.y) / 2};

            for (let node of cm.drawing.nodes) {
                if (node == edge.a || node == edge.b) continue;

                let d = Math.sqrt(Math.pow(node.x - point.x, 2) + Math.pow(node.y - point.y, 2));

                if (d < dis) {
                    // check if node is on good side of a line
                    if ((edge.b.x - edge.a.x)*(node.y - edge.a.y) - (edge.b.y - edge.a.y)*(node.x - edge.a.x) > 0) {
                        found = node;
                        dis = d;
                    } else {
                        // wrong side of the line
                        continue;
                    }
                }
            }
            return {node: found, distance: dis};
        }

        function findNearestNode(node, nodes) {

            let found = null;
            let dis = Number.POSITIVE_INFINITY;

            for (let n of nodes) {
                if (n == node) continue;

                let d = Math.sqrt(Math.pow(n.x - node.x, 2) + Math.pow(n.y - node.y, 2));

                if (d < dis) {
                    found = n;
                    dis = d;
                }
            }

            return found;
        }

        document.body.addEventListener("keyup", (event) => {
            //console.log(event);
            if (event.key == "p") {
                console.time("connect-points");
                connectAllNodes();
                console.timeEnd("connect-points");

                cm.drawing.redraw();
            }
            if (event.key == "n") {

                cm.drawing.redraw();
            }
            if (event.key == "r") {
                cm.drawing.redraw();
            }
        })
    </script>
</body>
</html>