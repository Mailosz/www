<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div style="border: 2px black solid; display: inline-block; width: 80%; height: 80%">
        <canvas id="tst-canvas" width="400" height="300" style="width: 100%; height: 100%;">

        </canvas>
    </div>
    <script id="vertex-shader-2d" type="notjs">
 
        // an attribute will receive data from a buffer
        attribute vec4 a_position;
       
        // all shaders have a main function
        void main() {
       
          // gl_Position is a special variable a vertex shader
          // is responsible for setting
          gl_Position = a_position;
        }
       
    </script>
    <script id="fragment-shader-2d" type="notjs">
 
        // fragment shaders don't have a default precision so we need
        // to pick one. mediump is a good default
        precision mediump float;
       
        void main() {
          // gl_FragColor is a special variable a fragment shader
          // is responsible for setting
          gl_FragColor = vec4(1, 0, 0.5, 1); // return reddish-purple
        }
       
      </script>
    <script>
        
        let canvasElement = document.getElementById('tst-canvas');
        let gl = canvasElement.getContext("webgl");
        
        const canvasToDisplaySizeMap = new Map([[canvasElement, [300, 150]]]);
        if (!gl) {
            console.error("WebGL error");
        }
        
        var vertexShaderSource = document.querySelector("#vertex-shader-2d").text;
        var fragmentShaderSource = document.querySelector("#fragment-shader-2d").text;
        
        var vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        
        var program = createProgram(gl, vertexShader, fragmentShader);
        
        //set position
        var positionAttributeLocation = gl.getAttribLocation(program, "a_position");
        var positionBuffer = gl.createBuffer();
        
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

        // three 2d points
        var positions = [
        0, 0,
        0, 0.2,
        0.7, 1,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.DYNAMIC_DRAW);

        //resize the canvas
        resizeCanvasToDisplaySize(gl.canvas);
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

        // Clear the canvas
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
    
        // Tell it to use our program (pair of shaders)
        gl.useProgram(program);

        gl.enableVertexAttribArray(positionAttributeLocation);


        // Bind the position buffer.
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        
        // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
        var size = 2;          // 2 components per iteration
        var type = gl.FLOAT;   // the data is 32bit floats
        var normalize = false; // don't normalize the data
        var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position
        var offset = 0;        // start at the beginning of the buffer
        gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset)

        var primitiveType = gl.TRIANGLES;
        var offset = 0;
        var count = 3;
        gl.drawArrays(primitiveType, offset, count);

        function createShader(gl, type, source) {
            var shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
            if (success) {
                return shader;
            }
            
            console.log(gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            var program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            var success = gl.getProgramParameter(program, gl.LINK_STATUS);
            if (success) {
                return program;
            }
            
            console.log(gl.getProgramInfoLog(program));
            gl.deleteProgram(program);
        }

        function resizeCanvasToDisplaySize(canvas) { console.log(100);
            // Get the size the browser is displaying the canvas in device pixels.
            const [displayWidth, displayHeight] = canvasToDisplaySizeMap.get(canvas);
            
            // Check if the canvas is not the same size.
            const needResize = canvas.width  != displayWidth || 
                                canvas.height != displayHeight;
            
            if (needResize) {
                // Make the canvas the same size
                canvas.width  = displayWidth;
                canvas.height = displayHeight;
            }

            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            
            return needResize;
        }

        const resizeObserver = new ResizeObserver(onResize);
        try {
        // only call us of the number of device pixels changed
        resizeObserver.observe(canvasElement, {box: 'device-pixel-content-box'});
        } catch (ex) {
        // device-pixel-content-box is not supported so fallback to this
        resizeObserver.observe(canvasElement, {box: 'content-box'});
        }


 
        function onResize(entries) {
            for (const entry of entries) {
                let width;
                let height;
                let dpr = window.devicePixelRatio;
                if (entry.devicePixelContentBoxSize) {
                // NOTE: Only this path gives the correct answer
                // The other paths are imperfect fallbacks
                // for browsers that don't provide anyway to do this
                width = entry.devicePixelContentBoxSize[0].inlineSize;
                height = entry.devicePixelContentBoxSize[0].blockSize;

                dpr = 1; // it's already in width and height
                } else if (entry.contentBoxSize) {
                if (entry.contentBoxSize[0]) {
                    width = entry.contentBoxSize[0].inlineSize;
                    height = entry.contentBoxSize[0].blockSize;
                } else {
                    width = entry.contentBoxSize.inlineSize;
                    height = entry.contentBoxSize.blockSize;
                }
                } else {
                width = entry.contentRect.width;
                height = entry.contentRect.height;
                }
                const displayWidth = Math.round(width * dpr);
                const displayHeight = Math.round(height * dpr);
                canvasToDisplaySizeMap.set(entry.target, [displayWidth, displayHeight]);
            }
        }

        setInterval(()=> resizeCanvasToDisplaySize(canvasElement), 1000);
    </script>
</body>
</html>